(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{286:function(t,a,v){"use strict";v.r(a);var _=v(38),r=Object(_.a)({},function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"kafka、rabbitmq、rocketmq等消息中间件的对比-——-消息发送性能和区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#kafka、rabbitmq、rocketmq等消息中间件的对比-——-消息发送性能和区别","aria-hidden":"true"}},[t._v("#")]),t._v(" Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别")]),t._v(" "),v("h2",{attrs:{id:"测试场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#测试场景","aria-hidden":"true"}},[t._v("#")]),t._v(" 测试场景")]),t._v(" "),v("p",[t._v("在同步发送场景中，三个消息中间件的表现区分明显：")]),t._v(" "),v("p",[t._v("Kafka的吞吐量高达17.3w/s，不愧是高吞吐量消息中间件的行业老大。这主要取决于它的队列模式保证了写磁盘的过程是线性IO。此时broker磁盘IO已达瓶颈。")]),t._v(" "),v("p",[t._v("RocketMQ也表现不俗，吞吐量在11.6w/s，磁盘IO %util已接近100%。RocketMQ的消息写入内存后即返回ack，由单独的线程专门做刷盘的操作，所有的消息均是顺序写文件。")]),t._v(" "),v("p",[t._v("RabbitMQ的吞吐量5.95w/s，CPU资源消耗较高。它支持AMQP协议，实现非常重量级，为了保证消息的可靠性在吞吐量上做了取舍。我们还做了RabbitMQ在消息持久化场景下的性能测试，吞吐量在2.6w/s左右。")]),t._v(" "),v("h2",{attrs:{id:"测试结论"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#测试结论","aria-hidden":"true"}},[t._v("#")]),t._v(" 测试结论")]),t._v(" "),v("p",[t._v("在服务端处理同步发送的性能上，Kafka>RocketMQ>RabbitMQ。")]),t._v(" "),v("p",[t._v("rabbitmq比kafka可靠，kafka更适合IO高吞吐的处理，比如ELK日志收集**")]),t._v(" "),v("h2",{attrs:{id:"在应用场景方面"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#在应用场景方面","aria-hidden":"true"}},[t._v("#")]),t._v(" 在应用场景方面")]),t._v(" "),v("p",[t._v("RabbitMQ,遵循AMQP协议，由内在高并发的erlanng语言开发，用在实时的对可靠性要求比较高的消息传递上。")]),t._v(" "),v("p",[t._v("kafka是Linkedin于2010年12月份开源的消息发布订阅系统,它主要用于处理活跃的流式数据,大数据量的数据处理上。")]),t._v(" "),v("h2",{attrs:{id:"在架构模型方面"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#在架构模型方面","aria-hidden":"true"}},[t._v("#")]),t._v(" 在架构模型方面")]),t._v(" "),v("p",[t._v("RabbitMQ遵循AMQP协议，RabbitMQ的broker由Exchange,Binding,queue组成，其中exchange和binding组成了消息的路由键；客户端Producer通过连接channel和server进行通信，Consumer从queue获取消息进行消费（长连接，queue有消息会推送到consumer端，consumer循环从输入流读取数据）。rabbitMQ以broker为中心；有消息的确认机制。")]),t._v(" "),v("p",[t._v("kafka遵从一般的MQ结构，producer，broker，consumer，以consumer为中心，消息的消费信息保存的客户端consumer上，consumer根据消费的点，从broker上批量pull数据；无消息确认机制。")]),t._v(" "),v("h2",{attrs:{id:"在可用性方面"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#在可用性方面","aria-hidden":"true"}},[t._v("#")]),t._v(" 在可用性方面")]),t._v(" "),v("p",[t._v("rabbitMQ支持miror的queue，主queue失效，miror queue接管。")]),t._v(" "),v("p",[t._v("kafka的broker支持主备模式。")]),t._v(" "),v("h2",{attrs:{id:"实际运用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实际运用","aria-hidden":"true"}},[t._v("#")]),t._v(" 实际运用")]),t._v(" "),v("h3",{attrs:{id:"为什么使用消息队列？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用消息队列？","aria-hidden":"true"}},[t._v("#")]),t._v(" 为什么使用消息队列？")]),t._v(" "),v("p",[t._v("解耦、异步、削峰")]),t._v(" "),v("h2",{attrs:{id:"区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#区别","aria-hidden":"true"}},[t._v("#")]),t._v(" 区别")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th"),t._v(" "),v("th",[t._v("ActiveMQ")]),t._v(" "),v("th",[t._v("RabbitMQ")]),t._v(" "),v("th",[t._v("RocketMQ")]),t._v(" "),v("th",[t._v("Kafka")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("单机吞吐量")]),t._v(" "),v("td",[t._v("万级，比 RocketMQ、Kafka 低一个数量级")]),t._v(" "),v("td",[t._v("同 ActiveMQ")]),t._v(" "),v("td",[t._v("10 万级，支撑高吞吐")]),t._v(" "),v("td",[t._v("10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景")])]),t._v(" "),v("tr",[v("td",[t._v("topic 数量对吞吐量的影响")]),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td",[t._v("topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic")]),t._v(" "),v("td",[t._v("topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源")])]),t._v(" "),v("tr",[v("td",[t._v("时效性")]),t._v(" "),v("td",[t._v("ms 级")]),t._v(" "),v("td",[t._v("微秒级，这是 RabbitMQ 的一大特点，延迟最低")]),t._v(" "),v("td",[t._v("ms 级")]),t._v(" "),v("td",[t._v("延迟在 ms 级以内")])]),t._v(" "),v("tr",[v("td",[t._v("可用性")]),t._v(" "),v("td",[t._v("高，基于主从架构实现高可用")]),t._v(" "),v("td",[t._v("同 ActiveMQ")]),t._v(" "),v("td",[t._v("非常高，分布式架构")]),t._v(" "),v("td",[t._v("非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用")])]),t._v(" "),v("tr",[v("td",[t._v("消息可靠性")]),t._v(" "),v("td",[t._v("有较低的概率丢失数据")]),t._v(" "),v("td",[t._v("基本不丢")]),t._v(" "),v("td",[t._v("经过参数优化配置，可以做到 0 丢失")]),t._v(" "),v("td",[t._v("同 RocketMQ")])]),t._v(" "),v("tr",[v("td",[t._v("功能支持")]),t._v(" "),v("td",[t._v("MQ 领域的功能极其完备")]),t._v(" "),v("td",[t._v("基于 erlang 开发，并发能力很强，性能极好，延时很低")]),t._v(" "),v("td",[t._v("MQ 功能较为完善，还是分布式的，扩展性好")]),t._v(" "),v("td",[t._v("功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用")])])])])])},[],!1,null,null,null);a.default=r.exports}}]);